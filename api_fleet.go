/*
SpaceTraders API

SpaceTraders is an open-universe game and learning platform that offers a set of HTTP endpoints to control a fleet of ships and explore a multiplayer universe.  The API is documented using [OpenAPI](https://github.com/SpaceTradersAPI/api-docs). You can send your first request right here in your browser to check the status of the game server.  ```json http {   \"method\": \"GET\",   \"url\": \"https://api.spacetraders.io/v2\", } ```  Unlike a traditional game, SpaceTraders does not have a first-party client or app to play the game. Instead, you can use the API to build your own client, write a script to automate your ships, or try an app built by the community.  We have a [Discord channel](https://discord.com/invite/jh6zurdWk5) where you can share your projects, ask questions, and get help from other players.   

API version: 2.0.0
Contact: joel@spacetraders.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spacetraders_api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type FleetApi interface {

	/*
	CreateChart Create Chart

	Command a ship to chart the current waypoint.

Waypoints in the universe are uncharted by default. These locations will not show up in the API until they have been charted by a ship.

Charting a location will record your agent as the one who created the chart.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship
	@return ApiCreateChartRequest
	*/
	CreateChart(ctx context.Context, shipSymbol string) ApiCreateChartRequest

	// CreateChartExecute executes the request
	//  @return CreateChart201Response
	CreateChartExecute(r ApiCreateChartRequest) (*CreateChart201Response, *http.Response, error)

	/*
	CreateShipShipScan Scan Ships

	Activate your ship's sensor arrays to scan for ship information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiCreateShipShipScanRequest
	*/
	CreateShipShipScan(ctx context.Context, shipSymbol string) ApiCreateShipShipScanRequest

	// CreateShipShipScanExecute executes the request
	//  @return CreateShipShipScan201Response
	CreateShipShipScanExecute(r ApiCreateShipShipScanRequest) (*CreateShipShipScan201Response, *http.Response, error)

	/*
	CreateShipSystemScan Scan Systems

	Activate your ship's sensor arrays to scan for system information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiCreateShipSystemScanRequest
	*/
	CreateShipSystemScan(ctx context.Context, shipSymbol string) ApiCreateShipSystemScanRequest

	// CreateShipSystemScanExecute executes the request
	//  @return CreateShipSystemScan201Response
	CreateShipSystemScanExecute(r ApiCreateShipSystemScanRequest) (*CreateShipSystemScan201Response, *http.Response, error)

	/*
	CreateShipWaypointScan Scan Waypoints

	Activate your ship's sensor arrays to scan for waypoint information.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiCreateShipWaypointScanRequest
	*/
	CreateShipWaypointScan(ctx context.Context, shipSymbol string) ApiCreateShipWaypointScanRequest

	// CreateShipWaypointScanExecute executes the request
	//  @return CreateShipWaypointScan201Response
	CreateShipWaypointScanExecute(r ApiCreateShipWaypointScanRequest) (*CreateShipWaypointScan201Response, *http.Response, error)

	/*
	CreateSurvey Create Survey

	If you want to target specific yields for an extraction, you can survey a waypoint, such as an asteroid field, and send the survey in the body of the extract request. Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.

Your ship will enter a cooldown between consecutive survey requests. Surveys will eventually expire after a period of time. Multiple ships can use the same survey for extraction.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship
	@return ApiCreateSurveyRequest
	*/
	CreateSurvey(ctx context.Context, shipSymbol string) ApiCreateSurveyRequest

	// CreateSurveyExecute executes the request
	//  @return CreateSurvey201Response
	CreateSurveyExecute(r ApiCreateSurveyRequest) (*CreateSurvey201Response, *http.Response, error)

	/*
	DockShip Dock Ship

	Attempt to dock your ship at it's current location. Docking will only succeed if the waypoint is a dockable location, and your ship is capable of docking at the time of the request.

The endpoint is idempotent - successive calls will succeed even if the ship is already docked.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship
	@return ApiDockShipRequest
	*/
	DockShip(ctx context.Context, shipSymbol string) ApiDockShipRequest

	// DockShipExecute executes the request
	//  @return DockShip200Response
	DockShipExecute(r ApiDockShipRequest) (*DockShip200Response, *http.Response, error)

	/*
	ExtractResources Extract Resources

	Extract resources from the waypoint into your ship. Send an optional survey as the payload to target specific yields.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol
	@return ApiExtractResourcesRequest
	*/
	ExtractResources(ctx context.Context, shipSymbol string) ApiExtractResourcesRequest

	// ExtractResourcesExecute executes the request
	//  @return ExtractResources201Response
	ExtractResourcesExecute(r ApiExtractResourcesRequest) (*ExtractResources201Response, *http.Response, error)

	/*
	GetMyShip Get Ship

	Retrieve the details of your ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiGetMyShipRequest
	*/
	GetMyShip(ctx context.Context, shipSymbol string) ApiGetMyShipRequest

	// GetMyShipExecute executes the request
	//  @return GetMyShip200Response
	GetMyShipExecute(r ApiGetMyShipRequest) (*GetMyShip200Response, *http.Response, error)

	/*
	GetMyShipCargo Get Ship Cargo

	Retrieve the cargo of your ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship
	@return ApiGetMyShipCargoRequest
	*/
	GetMyShipCargo(ctx context.Context, shipSymbol string) ApiGetMyShipCargoRequest

	// GetMyShipCargoExecute executes the request
	//  @return GetMyShipCargo200Response
	GetMyShipCargoExecute(r ApiGetMyShipCargoRequest) (*GetMyShipCargo200Response, *http.Response, error)

	/*
	GetMyShips List Ships

	Retrieve all of your ships.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMyShipsRequest
	*/
	GetMyShips(ctx context.Context) ApiGetMyShipsRequest

	// GetMyShipsExecute executes the request
	//  @return GetMyShips200Response
	GetMyShipsExecute(r ApiGetMyShipsRequest) (*GetMyShips200Response, *http.Response, error)

	/*
	GetShipCooldown Get Ship Cooldown

	Retrieve the details of your ship's reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.

Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.

Response returns a 204 status code (no-content) when the ship has no cooldown.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiGetShipCooldownRequest
	*/
	GetShipCooldown(ctx context.Context, shipSymbol string) ApiGetShipCooldownRequest

	// GetShipCooldownExecute executes the request
	//  @return GetShipCooldown200Response
	GetShipCooldownExecute(r ApiGetShipCooldownRequest) (*GetShipCooldown200Response, *http.Response, error)

	/*
	GetShipNav Get Ship Nav

	Get the current nav status of a ship.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol
	@return ApiGetShipNavRequest
	*/
	GetShipNav(ctx context.Context, shipSymbol string) ApiGetShipNavRequest

	// GetShipNavExecute executes the request
	//  @return GetShipNav200Response
	GetShipNavExecute(r ApiGetShipNavRequest) (*GetShipNav200Response, *http.Response, error)

	/*
	Jettison Jettison Cargo

	Jettison cargo from your ship's cargo hold.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiJettisonRequest
	*/
	Jettison(ctx context.Context, shipSymbol string) ApiJettisonRequest

	// JettisonExecute executes the request
	//  @return Jettison200Response
	JettisonExecute(r ApiJettisonRequest) (*Jettison200Response, *http.Response, error)

	/*
	JumpShip Jump Ship

	Jump your ship instantly to a target system. Unlike other forms of navigation, jumping requires a unit of antimatter.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiJumpShipRequest
	*/
	JumpShip(ctx context.Context, shipSymbol string) ApiJumpShipRequest

	// JumpShipExecute executes the request
	//  @return JumpShip200Response
	JumpShipExecute(r ApiJumpShipRequest) (*JumpShip200Response, *http.Response, error)

	/*
	NavigateShip Navigate Ship

	Navigate to a target destination. The destination must be located within the same system as the ship. Navigating will consume the necessary fuel and supplies from the ship's manifest, and will pay out crew wages from the agent's account.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it's destination.

To travel between systems, see the ship's warp or jump actions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol
	@return ApiNavigateShipRequest
	*/
	NavigateShip(ctx context.Context, shipSymbol string) ApiNavigateShipRequest

	// NavigateShipExecute executes the request
	//  @return NavigateShip200Response
	NavigateShipExecute(r ApiNavigateShipRequest) (*NavigateShip200Response, *http.Response, error)

	/*
	OrbitShip Orbit Ship

	Attempt to move your ship into orbit at it's current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.

The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship
	@return ApiOrbitShipRequest
	*/
	OrbitShip(ctx context.Context, shipSymbol string) ApiOrbitShipRequest

	// OrbitShipExecute executes the request
	//  @return OrbitShip200Response
	OrbitShipExecute(r ApiOrbitShipRequest) (*OrbitShip200Response, *http.Response, error)

	/*
	PatchShipNav Patch Ship Nav

	Update the nav data of a ship, such as the flight mode.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The ship symbol
	@return ApiPatchShipNavRequest
	*/
	PatchShipNav(ctx context.Context, shipSymbol string) ApiPatchShipNavRequest

	// PatchShipNavExecute executes the request
	//  @return GetShipNav200Response
	PatchShipNavExecute(r ApiPatchShipNavRequest) (*GetShipNav200Response, *http.Response, error)

	/*
	PurchaseCargo Purchase Cargo

	Purchase cargo.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiPurchaseCargoRequest
	*/
	PurchaseCargo(ctx context.Context, shipSymbol string) ApiPurchaseCargoRequest

	// PurchaseCargoExecute executes the request
	//  @return PurchaseCargo201Response
	PurchaseCargoExecute(r ApiPurchaseCargoRequest) (*PurchaseCargo201Response, *http.Response, error)

	/*
	PurchaseShip Purchase Ship

	Purchase a ship

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPurchaseShipRequest
	*/
	PurchaseShip(ctx context.Context) ApiPurchaseShipRequest

	// PurchaseShipExecute executes the request
	//  @return PurchaseShip201Response
	PurchaseShipExecute(r ApiPurchaseShipRequest) (*PurchaseShip201Response, *http.Response, error)

	/*
	RefuelShip Refuel Ship

	Refuel your ship from the local market.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiRefuelShipRequest
	*/
	RefuelShip(ctx context.Context, shipSymbol string) ApiRefuelShipRequest

	// RefuelShipExecute executes the request
	//  @return RefuelShip200Response
	RefuelShipExecute(r ApiRefuelShipRequest) (*RefuelShip200Response, *http.Response, error)

	/*
	SellCargo Sell Cargo

	Sell cargo.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiSellCargoRequest
	*/
	SellCargo(ctx context.Context, shipSymbol string) ApiSellCargoRequest

	// SellCargoExecute executes the request
	//  @return SellCargo201Response
	SellCargoExecute(r ApiSellCargoRequest) (*SellCargo201Response, *http.Response, error)

	/*
	ShipRefine Ship Refine

	Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol The symbol of the ship
	@return ApiShipRefineRequest
	*/
	ShipRefine(ctx context.Context, shipSymbol string) ApiShipRefineRequest

	// ShipRefineExecute executes the request
	//  @return ShipRefine200Response
	ShipRefineExecute(r ApiShipRefineRequest) (*ShipRefine200Response, *http.Response, error)

	/*
	TransferCargo Transfer Cargo

	Transfer cargo between ships.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiTransferCargoRequest
	*/
	TransferCargo(ctx context.Context, shipSymbol string) ApiTransferCargoRequest

	// TransferCargoExecute executes the request
	//  @return TransferCargo200Response
	TransferCargoExecute(r ApiTransferCargoRequest) (*TransferCargo200Response, *http.Response, error)

	/*
	WarpShip Warp Ship

	Warp your ship to a target destination in another system. Warping will consume the necessary fuel and supplies from the ship's manifest, and will pay out crew wages from the agent's account.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it's destination.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param shipSymbol
	@return ApiWarpShipRequest
	*/
	WarpShip(ctx context.Context, shipSymbol string) ApiWarpShipRequest

	// WarpShipExecute executes the request
	//  @return NavigateShip200Response
	WarpShipExecute(r ApiWarpShipRequest) (*NavigateShip200Response, *http.Response, error)
}

// FleetApiService FleetApi service
type FleetApiService service

type ApiCreateChartRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiCreateChartRequest) Execute() (*CreateChart201Response, *http.Response, error) {
	return r.ApiService.CreateChartExecute(r)
}

/*
CreateChart Create Chart

Command a ship to chart the current waypoint.

Waypoints in the universe are uncharted by default. These locations will not show up in the API until they have been charted by a ship.

Charting a location will record your agent as the one who created the chart.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The symbol of the ship
 @return ApiCreateChartRequest
*/
func (a *FleetApiService) CreateChart(ctx context.Context, shipSymbol string) ApiCreateChartRequest {
	return ApiCreateChartRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return CreateChart201Response
func (a *FleetApiService) CreateChartExecute(r ApiCreateChartRequest) (*CreateChart201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateChart201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.CreateChart")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/chart"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShipShipScanRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiCreateShipShipScanRequest) Execute() (*CreateShipShipScan201Response, *http.Response, error) {
	return r.ApiService.CreateShipShipScanExecute(r)
}

/*
CreateShipShipScan Scan Ships

Activate your ship's sensor arrays to scan for ship information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiCreateShipShipScanRequest
*/
func (a *FleetApiService) CreateShipShipScan(ctx context.Context, shipSymbol string) ApiCreateShipShipScanRequest {
	return ApiCreateShipShipScanRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return CreateShipShipScan201Response
func (a *FleetApiService) CreateShipShipScanExecute(r ApiCreateShipShipScanRequest) (*CreateShipShipScan201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateShipShipScan201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.CreateShipShipScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scan/ships"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShipSystemScanRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiCreateShipSystemScanRequest) Execute() (*CreateShipSystemScan201Response, *http.Response, error) {
	return r.ApiService.CreateShipSystemScanExecute(r)
}

/*
CreateShipSystemScan Scan Systems

Activate your ship's sensor arrays to scan for system information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiCreateShipSystemScanRequest
*/
func (a *FleetApiService) CreateShipSystemScan(ctx context.Context, shipSymbol string) ApiCreateShipSystemScanRequest {
	return ApiCreateShipSystemScanRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return CreateShipSystemScan201Response
func (a *FleetApiService) CreateShipSystemScanExecute(r ApiCreateShipSystemScanRequest) (*CreateShipSystemScan201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateShipSystemScan201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.CreateShipSystemScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scan/systems"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateShipWaypointScanRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiCreateShipWaypointScanRequest) Execute() (*CreateShipWaypointScan201Response, *http.Response, error) {
	return r.ApiService.CreateShipWaypointScanExecute(r)
}

/*
CreateShipWaypointScan Scan Waypoints

Activate your ship's sensor arrays to scan for waypoint information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiCreateShipWaypointScanRequest
*/
func (a *FleetApiService) CreateShipWaypointScan(ctx context.Context, shipSymbol string) ApiCreateShipWaypointScanRequest {
	return ApiCreateShipWaypointScanRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return CreateShipWaypointScan201Response
func (a *FleetApiService) CreateShipWaypointScanExecute(r ApiCreateShipWaypointScanRequest) (*CreateShipWaypointScan201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateShipWaypointScan201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.CreateShipWaypointScan")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/scan/waypoints"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSurveyRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiCreateSurveyRequest) Execute() (*CreateSurvey201Response, *http.Response, error) {
	return r.ApiService.CreateSurveyExecute(r)
}

/*
CreateSurvey Create Survey

If you want to target specific yields for an extraction, you can survey a waypoint, such as an asteroid field, and send the survey in the body of the extract request. Each survey may have multiple deposits, and if a symbol shows up more than once, that indicates a higher chance of extracting that resource.

Your ship will enter a cooldown between consecutive survey requests. Surveys will eventually expire after a period of time. Multiple ships can use the same survey for extraction.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The symbol of the ship
 @return ApiCreateSurveyRequest
*/
func (a *FleetApiService) CreateSurvey(ctx context.Context, shipSymbol string) ApiCreateSurveyRequest {
	return ApiCreateSurveyRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return CreateSurvey201Response
func (a *FleetApiService) CreateSurveyExecute(r ApiCreateSurveyRequest) (*CreateSurvey201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateSurvey201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.CreateSurvey")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/survey"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDockShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiDockShipRequest) Execute() (*DockShip200Response, *http.Response, error) {
	return r.ApiService.DockShipExecute(r)
}

/*
DockShip Dock Ship

Attempt to dock your ship at it's current location. Docking will only succeed if the waypoint is a dockable location, and your ship is capable of docking at the time of the request.

The endpoint is idempotent - successive calls will succeed even if the ship is already docked.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The symbol of the ship
 @return ApiDockShipRequest
*/
func (a *FleetApiService) DockShip(ctx context.Context, shipSymbol string) ApiDockShipRequest {
	return ApiDockShipRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return DockShip200Response
func (a *FleetApiService) DockShipExecute(r ApiDockShipRequest) (*DockShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DockShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.DockShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/dock"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExtractResourcesRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	extractResourcesRequest *ExtractResourcesRequest
}

func (r ApiExtractResourcesRequest) ExtractResourcesRequest(extractResourcesRequest ExtractResourcesRequest) ApiExtractResourcesRequest {
	r.extractResourcesRequest = &extractResourcesRequest
	return r
}

func (r ApiExtractResourcesRequest) Execute() (*ExtractResources201Response, *http.Response, error) {
	return r.ApiService.ExtractResourcesExecute(r)
}

/*
ExtractResources Extract Resources

Extract resources from the waypoint into your ship. Send an optional survey as the payload to target specific yields.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The ship symbol
 @return ApiExtractResourcesRequest
*/
func (a *FleetApiService) ExtractResources(ctx context.Context, shipSymbol string) ApiExtractResourcesRequest {
	return ApiExtractResourcesRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return ExtractResources201Response
func (a *FleetApiService) ExtractResourcesExecute(r ApiExtractResourcesRequest) (*ExtractResources201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExtractResources201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.ExtractResources")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/extract"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.extractResourcesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiGetMyShipRequest) Execute() (*GetMyShip200Response, *http.Response, error) {
	return r.ApiService.GetMyShipExecute(r)
}

/*
GetMyShip Get Ship

Retrieve the details of your ship.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiGetMyShipRequest
*/
func (a *FleetApiService) GetMyShip(ctx context.Context, shipSymbol string) ApiGetMyShipRequest {
	return ApiGetMyShipRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return GetMyShip200Response
func (a *FleetApiService) GetMyShipExecute(r ApiGetMyShipRequest) (*GetMyShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.GetMyShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyShipCargoRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiGetMyShipCargoRequest) Execute() (*GetMyShipCargo200Response, *http.Response, error) {
	return r.ApiService.GetMyShipCargoExecute(r)
}

/*
GetMyShipCargo Get Ship Cargo

Retrieve the cargo of your ship.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The symbol of the ship
 @return ApiGetMyShipCargoRequest
*/
func (a *FleetApiService) GetMyShipCargo(ctx context.Context, shipSymbol string) ApiGetMyShipCargoRequest {
	return ApiGetMyShipCargoRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return GetMyShipCargo200Response
func (a *FleetApiService) GetMyShipCargoExecute(r ApiGetMyShipCargoRequest) (*GetMyShipCargo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyShipCargo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.GetMyShipCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/cargo"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyShipsRequest struct {
	ctx context.Context
	ApiService FleetApi
	page *int32
	limit *int32
}

// What entry offset to request
func (r ApiGetMyShipsRequest) Page(page int32) ApiGetMyShipsRequest {
	r.page = &page
	return r
}

// How many entries to return per page
func (r ApiGetMyShipsRequest) Limit(limit int32) ApiGetMyShipsRequest {
	r.limit = &limit
	return r
}

func (r ApiGetMyShipsRequest) Execute() (*GetMyShips200Response, *http.Response, error) {
	return r.ApiService.GetMyShipsExecute(r)
}

/*
GetMyShips List Ships

Retrieve all of your ships.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyShipsRequest
*/
func (a *FleetApiService) GetMyShips(ctx context.Context) ApiGetMyShipsRequest {
	return ApiGetMyShipsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetMyShips200Response
func (a *FleetApiService) GetMyShipsExecute(r ApiGetMyShipsRequest) (*GetMyShips200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMyShips200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.GetMyShips")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShipCooldownRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiGetShipCooldownRequest) Execute() (*GetShipCooldown200Response, *http.Response, error) {
	return r.ApiService.GetShipCooldownExecute(r)
}

/*
GetShipCooldown Get Ship Cooldown

Retrieve the details of your ship's reactor cooldown. Some actions such as activating your jump drive, scanning, or extracting resources taxes your reactor and results in a cooldown.

Your ship cannot perform additional actions until your cooldown has expired. The duration of your cooldown is relative to the power consumption of the related modules or mounts for the action taken.

Response returns a 204 status code (no-content) when the ship has no cooldown.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiGetShipCooldownRequest
*/
func (a *FleetApiService) GetShipCooldown(ctx context.Context, shipSymbol string) ApiGetShipCooldownRequest {
	return ApiGetShipCooldownRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return GetShipCooldown200Response
func (a *FleetApiService) GetShipCooldownExecute(r ApiGetShipCooldownRequest) (*GetShipCooldown200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShipCooldown200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.GetShipCooldown")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/cooldown"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetShipNavRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiGetShipNavRequest) Execute() (*GetShipNav200Response, *http.Response, error) {
	return r.ApiService.GetShipNavExecute(r)
}

/*
GetShipNav Get Ship Nav

Get the current nav status of a ship.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The ship symbol
 @return ApiGetShipNavRequest
*/
func (a *FleetApiService) GetShipNav(ctx context.Context, shipSymbol string) ApiGetShipNavRequest {
	return ApiGetShipNavRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return GetShipNav200Response
func (a *FleetApiService) GetShipNavExecute(r ApiGetShipNavRequest) (*GetShipNav200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShipNav200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.GetShipNav")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/nav"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJettisonRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	jettisonRequest *JettisonRequest
}

func (r ApiJettisonRequest) JettisonRequest(jettisonRequest JettisonRequest) ApiJettisonRequest {
	r.jettisonRequest = &jettisonRequest
	return r
}

func (r ApiJettisonRequest) Execute() (*Jettison200Response, *http.Response, error) {
	return r.ApiService.JettisonExecute(r)
}

/*
Jettison Jettison Cargo

Jettison cargo from your ship's cargo hold.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiJettisonRequest
*/
func (a *FleetApiService) Jettison(ctx context.Context, shipSymbol string) ApiJettisonRequest {
	return ApiJettisonRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return Jettison200Response
func (a *FleetApiService) JettisonExecute(r ApiJettisonRequest) (*Jettison200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Jettison200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.Jettison")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/jettison"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jettisonRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiJumpShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	jumpShipRequest *JumpShipRequest
}

func (r ApiJumpShipRequest) JumpShipRequest(jumpShipRequest JumpShipRequest) ApiJumpShipRequest {
	r.jumpShipRequest = &jumpShipRequest
	return r
}

func (r ApiJumpShipRequest) Execute() (*JumpShip200Response, *http.Response, error) {
	return r.ApiService.JumpShipExecute(r)
}

/*
JumpShip Jump Ship

Jump your ship instantly to a target system. Unlike other forms of navigation, jumping requires a unit of antimatter.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiJumpShipRequest
*/
func (a *FleetApiService) JumpShip(ctx context.Context, shipSymbol string) ApiJumpShipRequest {
	return ApiJumpShipRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return JumpShip200Response
func (a *FleetApiService) JumpShipExecute(r ApiJumpShipRequest) (*JumpShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *JumpShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.JumpShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/jump"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.jumpShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiNavigateShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	navigateShipRequest *NavigateShipRequest
}

// 
func (r ApiNavigateShipRequest) NavigateShipRequest(navigateShipRequest NavigateShipRequest) ApiNavigateShipRequest {
	r.navigateShipRequest = &navigateShipRequest
	return r
}

func (r ApiNavigateShipRequest) Execute() (*NavigateShip200Response, *http.Response, error) {
	return r.ApiService.NavigateShipExecute(r)
}

/*
NavigateShip Navigate Ship

Navigate to a target destination. The destination must be located within the same system as the ship. Navigating will consume the necessary fuel and supplies from the ship's manifest, and will pay out crew wages from the agent's account.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it's destination.

To travel between systems, see the ship's warp or jump actions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The ship symbol
 @return ApiNavigateShipRequest
*/
func (a *FleetApiService) NavigateShip(ctx context.Context, shipSymbol string) ApiNavigateShipRequest {
	return ApiNavigateShipRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return NavigateShip200Response
func (a *FleetApiService) NavigateShipExecute(r ApiNavigateShipRequest) (*NavigateShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NavigateShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.NavigateShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/navigate"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.navigateShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrbitShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiOrbitShipRequest) Execute() (*OrbitShip200Response, *http.Response, error) {
	return r.ApiService.OrbitShipExecute(r)
}

/*
OrbitShip Orbit Ship

Attempt to move your ship into orbit at it's current location. The request will only succeed if your ship is capable of moving into orbit at the time of the request.

The endpoint is idempotent - successive calls will succeed even if the ship is already in orbit.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The symbol of the ship
 @return ApiOrbitShipRequest
*/
func (a *FleetApiService) OrbitShip(ctx context.Context, shipSymbol string) ApiOrbitShipRequest {
	return ApiOrbitShipRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return OrbitShip200Response
func (a *FleetApiService) OrbitShipExecute(r ApiOrbitShipRequest) (*OrbitShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrbitShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.OrbitShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/orbit"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchShipNavRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	patchShipNavRequest *PatchShipNavRequest
}

func (r ApiPatchShipNavRequest) PatchShipNavRequest(patchShipNavRequest PatchShipNavRequest) ApiPatchShipNavRequest {
	r.patchShipNavRequest = &patchShipNavRequest
	return r
}

func (r ApiPatchShipNavRequest) Execute() (*GetShipNav200Response, *http.Response, error) {
	return r.ApiService.PatchShipNavExecute(r)
}

/*
PatchShipNav Patch Ship Nav

Update the nav data of a ship, such as the flight mode.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The ship symbol
 @return ApiPatchShipNavRequest
*/
func (a *FleetApiService) PatchShipNav(ctx context.Context, shipSymbol string) ApiPatchShipNavRequest {
	return ApiPatchShipNavRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return GetShipNav200Response
func (a *FleetApiService) PatchShipNavExecute(r ApiPatchShipNavRequest) (*GetShipNav200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetShipNav200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.PatchShipNav")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/nav"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchShipNavRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPurchaseCargoRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	purchaseCargoRequest *PurchaseCargoRequest
}

func (r ApiPurchaseCargoRequest) PurchaseCargoRequest(purchaseCargoRequest PurchaseCargoRequest) ApiPurchaseCargoRequest {
	r.purchaseCargoRequest = &purchaseCargoRequest
	return r
}

func (r ApiPurchaseCargoRequest) Execute() (*PurchaseCargo201Response, *http.Response, error) {
	return r.ApiService.PurchaseCargoExecute(r)
}

/*
PurchaseCargo Purchase Cargo

Purchase cargo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiPurchaseCargoRequest
*/
func (a *FleetApiService) PurchaseCargo(ctx context.Context, shipSymbol string) ApiPurchaseCargoRequest {
	return ApiPurchaseCargoRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return PurchaseCargo201Response
func (a *FleetApiService) PurchaseCargoExecute(r ApiPurchaseCargoRequest) (*PurchaseCargo201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseCargo201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.PurchaseCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/purchase"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.purchaseCargoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPurchaseShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	purchaseShipRequest *PurchaseShipRequest
}

func (r ApiPurchaseShipRequest) PurchaseShipRequest(purchaseShipRequest PurchaseShipRequest) ApiPurchaseShipRequest {
	r.purchaseShipRequest = &purchaseShipRequest
	return r
}

func (r ApiPurchaseShipRequest) Execute() (*PurchaseShip201Response, *http.Response, error) {
	return r.ApiService.PurchaseShipExecute(r)
}

/*
PurchaseShip Purchase Ship

Purchase a ship

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPurchaseShipRequest
*/
func (a *FleetApiService) PurchaseShip(ctx context.Context) ApiPurchaseShipRequest {
	return ApiPurchaseShipRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PurchaseShip201Response
func (a *FleetApiService) PurchaseShipExecute(r ApiPurchaseShipRequest) (*PurchaseShip201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PurchaseShip201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.PurchaseShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.purchaseShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRefuelShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
}

func (r ApiRefuelShipRequest) Execute() (*RefuelShip200Response, *http.Response, error) {
	return r.ApiService.RefuelShipExecute(r)
}

/*
RefuelShip Refuel Ship

Refuel your ship from the local market.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiRefuelShipRequest
*/
func (a *FleetApiService) RefuelShip(ctx context.Context, shipSymbol string) ApiRefuelShipRequest {
	return ApiRefuelShipRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return RefuelShip200Response
func (a *FleetApiService) RefuelShipExecute(r ApiRefuelShipRequest) (*RefuelShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RefuelShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.RefuelShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/refuel"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSellCargoRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	sellCargoRequest *SellCargoRequest
}

func (r ApiSellCargoRequest) SellCargoRequest(sellCargoRequest SellCargoRequest) ApiSellCargoRequest {
	r.sellCargoRequest = &sellCargoRequest
	return r
}

func (r ApiSellCargoRequest) Execute() (*SellCargo201Response, *http.Response, error) {
	return r.ApiService.SellCargoExecute(r)
}

/*
SellCargo Sell Cargo

Sell cargo.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiSellCargoRequest
*/
func (a *FleetApiService) SellCargo(ctx context.Context, shipSymbol string) ApiSellCargoRequest {
	return ApiSellCargoRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return SellCargo201Response
func (a *FleetApiService) SellCargoExecute(r ApiSellCargoRequest) (*SellCargo201Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SellCargo201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.SellCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/sell"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sellCargoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShipRefineRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	shipRefineRequest *ShipRefineRequest
}

func (r ApiShipRefineRequest) ShipRefineRequest(shipRefineRequest ShipRefineRequest) ApiShipRefineRequest {
	r.shipRefineRequest = &shipRefineRequest
	return r
}

func (r ApiShipRefineRequest) Execute() (*ShipRefine200Response, *http.Response, error) {
	return r.ApiService.ShipRefineExecute(r)
}

/*
ShipRefine Ship Refine

Attempt to refine the raw materials on your ship. The request will only succeed if your ship is capable of refining at the time of the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol The symbol of the ship
 @return ApiShipRefineRequest
*/
func (a *FleetApiService) ShipRefine(ctx context.Context, shipSymbol string) ApiShipRefineRequest {
	return ApiShipRefineRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return ShipRefine200Response
func (a *FleetApiService) ShipRefineExecute(r ApiShipRefineRequest) (*ShipRefine200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShipRefine200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.ShipRefine")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/refine"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.shipRefineRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferCargoRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	transferCargoRequest *TransferCargoRequest
}

func (r ApiTransferCargoRequest) TransferCargoRequest(transferCargoRequest TransferCargoRequest) ApiTransferCargoRequest {
	r.transferCargoRequest = &transferCargoRequest
	return r
}

func (r ApiTransferCargoRequest) Execute() (*TransferCargo200Response, *http.Response, error) {
	return r.ApiService.TransferCargoExecute(r)
}

/*
TransferCargo Transfer Cargo

Transfer cargo between ships.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiTransferCargoRequest
*/
func (a *FleetApiService) TransferCargo(ctx context.Context, shipSymbol string) ApiTransferCargoRequest {
	return ApiTransferCargoRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return TransferCargo200Response
func (a *FleetApiService) TransferCargoExecute(r ApiTransferCargoRequest) (*TransferCargo200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransferCargo200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.TransferCargo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.transferCargoRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWarpShipRequest struct {
	ctx context.Context
	ApiService FleetApi
	shipSymbol string
	navigateShipRequest *NavigateShipRequest
}

// 
func (r ApiWarpShipRequest) NavigateShipRequest(navigateShipRequest NavigateShipRequest) ApiWarpShipRequest {
	r.navigateShipRequest = &navigateShipRequest
	return r
}

func (r ApiWarpShipRequest) Execute() (*NavigateShip200Response, *http.Response, error) {
	return r.ApiService.WarpShipExecute(r)
}

/*
WarpShip Warp Ship

Warp your ship to a target destination in another system. Warping will consume the necessary fuel and supplies from the ship's manifest, and will pay out crew wages from the agent's account.

The returned response will detail the route information including the expected time of arrival. Most ship actions are unavailable until the ship has arrived at it's destination.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param shipSymbol
 @return ApiWarpShipRequest
*/
func (a *FleetApiService) WarpShip(ctx context.Context, shipSymbol string) ApiWarpShipRequest {
	return ApiWarpShipRequest{
		ApiService: a,
		ctx: ctx,
		shipSymbol: shipSymbol,
	}
}

// Execute executes the request
//  @return NavigateShip200Response
func (a *FleetApiService) WarpShipExecute(r ApiWarpShipRequest) (*NavigateShip200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NavigateShip200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FleetApiService.WarpShip")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/my/ships/{shipSymbol}/warp"
	localVarPath = strings.Replace(localVarPath, "{"+"shipSymbol"+"}", url.PathEscape(parameterValueToString(r.shipSymbol, "shipSymbol")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.navigateShipRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
